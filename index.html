<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS1 Horror FPS</title>
<style>
body{margin:0;overflow:hidden;background:black}
canvas{display:block;image-rendering:pixelated}
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");

function resize(){
canvas.width=window.innerWidth;
canvas.height=window.innerHeight;
}
resize();
window.addEventListener("resize",resize);

/* ===== TEXTURES ===== */
const wallTex=new Image();
wallTex.src="assets/wall.png";

const floorTex=new Image();
floorTex.src="assets/floor.png";

const ceilingTex=new Image();
ceilingTex.src="assets/ceiling.png";

const gunIdle=new Image();
gunIdle.src="assets/gun_idle.png";

const gunFire=new Image();
gunFire.src="assets/gun_fire.png";

const enemySprites=[];
for(let i=0;i<8;i++){
let img=new Image();
img.src=`assets/enemy_${i}.png`;
enemySprites.push(img);
}

/* ===== MAP ===== */
const map=[
"111111111111111",
"100000000000001",
"101111011111101",
"100001000000001",
"111101011111101",
"100001000100001",
"101111110101101",
"100000000000001",
"111111111111111"
];

function isWall(x,y){
let mx=Math.floor(x);
let my=Math.floor(y);
if(my<0||my>=map.length||mx<0||mx>=map[0].length) return true;
return map[my][mx]=="1";
}

/* ===== PLAYER ===== */
let player={x:2,y:2,angle:0};
let keys={};

let flash=0;
let recoil=0;

document.addEventListener("keydown",e=>keys[e.key]=true);
document.addEventListener("keyup",e=>keys[e.key]=false);

canvas.addEventListener("click",()=>{
canvas.requestPointerLock();
shoot();
});

document.addEventListener("mousemove",e=>{
if(document.pointerLockElement===canvas){
player.angle+=e.movementX*0.002;
}
});

/* ===== ENEMY ===== */
let enemies=[{x:6,y:6,dir:0}];

/* ===== SHOOT ===== */
function shoot(){
if(flash>0) return;
flash=6;
recoil=12;
}

/* ===== UPDATE ===== */
function update(){

let speed=0.05;
let nx=player.x;
let ny=player.y;

if(keys["w"]){ nx+=Math.cos(player.angle)*speed; ny+=Math.sin(player.angle)*speed;}
if(keys["s"]){ nx-=Math.cos(player.angle)*speed; ny-=Math.sin(player.angle)*speed;}
if(keys["a"]){ nx+=Math.cos(player.angle-Math.PI/2)*speed; ny+=Math.sin(player.angle-Math.PI/2)*speed;}
if(keys["d"]){ nx+=Math.cos(player.angle+Math.PI/2)*speed; ny+=Math.sin(player.angle+Math.PI/2)*speed;}

if(!isWall(nx,player.y)) player.x=nx;
if(!isWall(player.x,ny)) player.y=ny;

enemies.forEach(e=>{
let dx=player.x-e.x;
let dy=player.y-e.y;
e.dir=Math.atan2(dy,dx);
});

if(flash>0) flash--;
recoil*=0.8;
}

/* ===== RENDER ===== */
function render(){

ctx.clearRect(0,0,canvas.width,canvas.height);

/* ===== CEILING ===== */
if(ceilingTex.complete && ceilingTex.naturalWidth!==0){
ctx.drawImage(ceilingTex,0,0,canvas.width,canvas.height/2);
}else{
ctx.fillStyle="#222";
ctx.fillRect(0,0,canvas.width,canvas.height/2);
}

/* ===== FLOOR ===== */
if(floorTex.complete && floorTex.naturalWidth!==0){
ctx.drawImage(floorTex,0,canvas.height/2,canvas.width,canvas.height/2);
}else{
ctx.fillStyle="#111";
ctx.fillRect(0,canvas.height/2,canvas.width,canvas.height/2);
}

let rays=320;
let fov=Math.PI/3;

for(let i=0;i<rays;i++){

let angle=player.angle-fov/2+(i/rays)*fov;
let dist=0;

while(dist<20){
let rx=player.x+Math.cos(angle)*dist;
let ry=player.y+Math.sin(angle)*dist;
if(isWall(rx,ry)) break;
dist+=0.02;
}

let corrected=dist*Math.cos(angle-player.angle);
let wallH=canvas.height/(corrected+0.0001);
let wallX=i*(canvas.width/rays);

let hitX=player.x+Math.cos(angle)*dist;
let texX=(hitX%1);

if(wallTex.complete && wallTex.naturalWidth!==0){
ctx.drawImage(
wallTex,
texX*wallTex.width,0,1,wallTex.height,
wallX,
(canvas.height/2)-(wallH/2),
canvas.width/rays+1,
wallH
);
}else{
ctx.fillStyle="#884444";
ctx.fillRect(
wallX,
(canvas.height/2)-(wallH/2),
canvas.width/rays+1,
wallH
);
}

/* FOG */
let fog=Math.min(corrected/8,1);
ctx.fillStyle=`rgba(0,0,0,${fog})`;
ctx.fillRect(
wallX,
(canvas.height/2)-(wallH/2),
canvas.width/rays+1,
wallH
);
}

/* ===== ENEMY ===== */
enemies.forEach(e=>{

let dx=e.x-player.x;
let dy=e.y-player.y;
let dist=Math.hypot(dx,dy);
let ang=Math.atan2(dy,dx)-player.angle;
ang=(ang+Math.PI*3)%(Math.PI*2)-Math.PI;

if(Math.abs(ang)<fov/2){

let size=canvas.height/(dist);
let screenX=(ang/(fov/2))*canvas.width/2+canvas.width/2;

let relative=e.dir-player.angle;
relative=(relative+Math.PI*3)%(Math.PI*2);
let index=Math.floor((relative/(Math.PI*2))*8);
index=(index+8)%8;

if(enemySprites[index].complete && enemySprites[index].naturalWidth!==0){
ctx.drawImage(
enemySprites[index],
screenX-size/2,
canvas.height/2-size/2,
size,
size
);
}else{
ctx.fillStyle="lime";
ctx.fillRect(
screenX-size/4,
canvas.height/2-size/2,
size/2,
size
);
}

/* enemy fog */
let efog=Math.min(dist/8,1);
ctx.fillStyle=`rgba(0,0,0,${efog})`;
ctx.fillRect(
screenX-size/2,
canvas.height/2-size/2,
size,
size
);
}
});

/* ===== GUN ===== */
let gw=canvas.width*0.45;
let gh=canvas.height*0.4;
let gx=canvas.width-gw-30;
let gy=canvas.height-gh-10+recoil;

if(flash>0 && gunFire.complete){
ctx.drawImage(gunFire,gx,gy,gw,gh);
}else if(gunIdle.complete){
ctx.drawImage(gunIdle,gx,gy,gw,gh);
}else{
ctx.fillStyle="#333";
ctx.fillRect(gx,gy,gw,gh);
}

if(flash>0){
ctx.fillStyle="orange";
ctx.beginPath();
ctx.arc(gx+gw+10,gy+gh*0.4,25,0,Math.PI*2);
ctx.fill();
}

}

/* LOOP */
function loop(){
update();
render();
requestAnimationFrame(loop);
}
loop();

</script>
</body>
</html>